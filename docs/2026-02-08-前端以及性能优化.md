# 流量统计图重构

**日期**: 2026-02-08  
**类型**: 重构 (refactor)

## 概述

重新构建前端流量统计图部分，优化组件结构、提升性能和改进用户体验。

## 主要变更

### 1. 组件整合

**删除**:
- `frontend/src/components/TrafficChart.jsx` - 旧的流量图表组件

**优化**:
- `frontend/src/components/charts/SpeedChart.jsx` - 统一的速度趋势图组件
- `frontend/src/components/charts/TrafficChartSection.jsx` - 图表容器组件

### 2. 功能改进

#### SpeedChart 组件
- ✅ 支持面积图和折线图切换（通过 `showArea` 属性）
- ✅ 动态 Y 轴范围计算，自动适应数据规模
- ✅ 优化的 X 轴刻度显示（首、中、尾三个时间点）
- ✅ 改进的 Tooltip 交互体验
- ✅ 使用 CSS 变量适配主题（亮色/暗色模式）
- ✅ 性能优化：使用 `memo` 和 `useMemo` 减少重渲染

#### TrafficChartSection 组件
- ✅ 新增连接状态指示器（WebSocket/API 轮询/连接中）
- ✅ 显示历史数据时长
- ✅ 使用 Badge 组件美化状态显示
- ✅ 动画效果：WebSocket 连接时的脉冲动画

### 3. 工具函数优化

**chartHelpers.js** 新增功能:
- `calculateYAxisMax()` - 智能计算 Y 轴最大值
- `generateXAxisTicks()` - 生成合适的 X 轴刻度
- `chartTheme` - 统一的图表主题配置
- 改进的 `formatSpeed()` - 更精确的速度格式化

### 4. 视觉改进

- 🎨 使用渐变填充增强视觉效果
- 🎨 网格线使用虚线样式，降低视觉干扰
- 🎨 Tooltip 样式适配主题系统
- 🎨 图例使用方形符号，更清晰
- 🎨 连接状态指示器带动画效果

### 5. 响应式修复

- ✅ 修复流量图尺寸问题
- ✅ 添加容器宽度监听（使用 `ResizeObserver`）
- ✅ 图表宽度自动适应容器
- ✅ 窗口大小变化时自动重新计算宽度

## 技术细节

### 数据流
```
monitorStore (speedHistory)
    ↓
TrafficChartSection (容器 + 状态显示)
    ↓
SpeedChart (图表渲染)
```

### 性能优化
1. **memo 包裹组件**：避免不必要的重渲染
2. **useMemo 缓存计算**：
   - 数据格式转换
   - Y 轴最大值计算
   - X 轴刻度生成
3. **禁用动画**：Victory 图表动画在实时数据场景下会影响性能

### 主题适配
使用 CSS 变量实现主题切换：
```javascript
fill: 'hsl(var(--foreground))'
stroke: 'hsl(var(--border))'
```

## 构建结果

```
TrafficChartSection-B_F8or90.js    5.04 kB │ gzip: 2.18 kB
chart-vendor-DecMr12B.js         293.91 kB │ gzip: 93.94 kB
```

- 图表组件体积优化
- 代码分割良好
- Gzip 压缩率高

## 向后兼容性

✅ 完全兼容现有 API
- 数据格式不变
- Store 接口不变
- 组件 props 向后兼容

## 测试

- ✅ 编译检查通过
- ✅ 构建成功
- ✅ 无 TypeScript/ESLint 错误

## 后续优化建议

1. **数据采样**：当历史数据点过多时（>200），可以考虑采样显示
2. **缩放功能**：添加图表缩放和平移功能
3. **导出功能**：支持导出图表为图片
4. **多时间范围**：支持切换 1 分钟/5 分钟/30 分钟视图

## 相关文件

- `frontend/src/components/charts/SpeedChart.jsx`
- `frontend/src/components/charts/TrafficChartSection.jsx`
- `frontend/src/utils/chartHelpers.js`
- `frontend/src/store/monitorStore.js`

---

## 2026-02-08 更新：固定时间窗口显示

### 问题描述

刚启动时，流量趋势图的时间轴会逐渐从右往左推出，导致时间轴不够固定，用户体验不佳。

### 解决方案

修改图表数据转换逻辑，实现固定的2分钟（120秒）时间窗口：

**修改文件**: `frontend/src/components/charts/SpeedChart.jsx`

#### 核心变更

1. **固定槽位设计**：
   - 从动态数据点改为固定120个槽位（120秒）
   - 每个槽位代表1秒，从"当前时间-119秒"到"当前时间"
   - 缺失数据点的速度自动填充为0

2. **数据映射逻辑**：
   - 以最新数据点的时间戳作为基准（或使用当前时间）
   - 构建120个时间槽位，查找每个槽位对应的历史数据
   - 未匹配到数据的槽位显示0速度

3. **X轴刻度固定**：
   - 在固定120个槽位上均匀分布10个刻度
   - 时间轴始终保持稳定，不随数据量变化

### 技术实现

```javascript
// 固定120个槽位（120秒）
const FIXED_SLOTS = 120
const latestTimestamp = parseInt(speedHistory[speedHistory.length - 1].timestamp)

// 构建时间窗口
for (let i = 0; i < FIXED_SLOTS; i++) {
  const slotTimestamp = latestTimestamp - (FIXED_SLOTS - 1 - i)
  const matchedData = speedHistory.find(item => parseInt(item.timestamp) === slotTimestamp)

  fixedSlots.push({
    x: i,
    time: formatTime(slotTimestamp),
    upload: parseSpeedString(matchedData?.upload_speed || '0 B/s'),
    download: parseSpeedString(matchedData?.download_speed || '0 B/s'),
    timestamp: slotTimestamp
  })
}
```

### 效果

- ✅ 刚启动时就显示完整的2分钟时间窗口
- ✅ 缺失数据的时间段速度为0，预留空间
- ✅ 时间轴固定，不会逐渐推出
- ✅ 随着数据累积，从右向左填充图表
- ✅ 视觉体验更加稳定和直观

---

## 2026-02-08 更新：连接限制与性能优化

### 概述

实施后端 VLESS 连接数限制（1000个）和前端 WebSocket 多标签页协调（限制为5个连接），并进行全面的性能优化。

### 后端变更

#### 1. 连接限制实现

**修改文件**: `src/config.rs`, `src/stats.rs`, `src/server.rs`

**配置修改**:
- WebSocket 最大连接数：300 → **5**
- VLESS 最大连接数：300 → **1000**

**新增功能**:
- VLESS 连接数检查：在 UUID 验证后、ConnectionGuard 创建前检查当前连接数
- 拒绝连接计数器：使用 `AtomicU64` 原子操作记录拒绝的连接数
- 连接数获取方法：`Stats::get_active_connections()`

**代码示例**:
```rust
// 连接数检查
let current_connections = {
    let stats_guard = stats.lock().await;
    stats_guard.get_active_connections()
};

if current_connections >= monitoring_config.vless_max_connections {
    warn!("VLESS connection limit reached: {}/{} from {}",
          current_connections, monitoring_config.vless_max_connections, client_addr);
    stats.lock().await.increment_rejected_connections();
    return Err(anyhow!("Server connection limit reached"));
}
```

#### 2. 监控指标扩展

**新增字段**:
- `MonitorData.rejected_connections` - 拒绝的连接总数
- `Stats.rejected_connections` - 使用 `Arc<AtomicU64>` 实现，减少锁竞争

**API 返回示例**:
```json
{
  "active_connections": 150,
  "max_connections": 1000,
  "rejected_connections": 25
}
```

### 前端变更

#### 1. WebSocket 多标签页协调

**新增文件**: `frontend/src/api/ws-coordinator.js`

**核心机制**:
- 使用 **BroadcastChannel API** 实现多标签页协调
- 主从选举：选举一个"主连接"标签页负责创建 WebSocket 连接
- 数据广播：主连接通过 BroadcastChannel 广播数据给从标签页
- 心跳检测：主连接每5秒发送心跳，从标签页10秒未收到则重新选举

**架构图**:
```
┌─────────────────────────────────────────────────────────┐
│                   BroadcastChannel 'ws-coordinator'     │
└─────────────────────────────────────────────────────────┘
                          │
        ┌─────────────────┼─────────────────┐
        ▼                 ▼                 ▼
   ┌─────────┐      ┌─────────┐      ┌─────────┐
   │ Tab 1   │      │ Tab 2   │      │ Tab 3   │
   │ Master  │      │ Follower│      │ Follower│
   │ (WS连接) │      │ (无连接) │      │ (无连接) │
   └─────────┘      └─────────┘      └─────────┘
```

**实现细节**:
- 消息类型：`ELECT_MASTER`, `IAM_MASTER`, `MASTER_HEARTBEAT`, `DATA_BROADCAST`
- 选举超时：500ms
- 心跳间隔：5秒
- 心跳超时：10秒
- 降级策略：不支持 BroadcastChannel 的浏览器降级到独立连接

#### 2. 状态管理集成

**修改文件**: `frontend/src/store/monitorStore.js`

**主要变更**:
- 引入 `WebSocketCoordinator` 替代直接的 `WebSocketClient`
- `connect()` 方法改为调用协调器的选举机制
- 新增 `coordinator` 状态字段
- 兼容旧的 `wsClient` 字段

#### 3. 组件性能优化

**优化文件**:
- `frontend/src/components/metrics/ConnectionsMetric.jsx`
- `frontend/src/components/metrics/SpeedMetric.jsx`
- `frontend/src/components/metrics/MemoryMetric.jsx`
- `frontend/src/components/metrics/TrafficMetric.jsx`
- `frontend/src/components/metrics/UptimeMetric.jsx`
- `frontend/src/components/ResourceCard.jsx`
- `frontend/src/components/SystemInfo.jsx`

**优化措施**:
1. **React.memo**：所有组件使用 `memo` 包裹，避免不必要的重渲染
2. **useMemo**：缓存计算密集型操作（百分比、状态判断、颜色类）
3. **静态对象外移**：`colorClasses` 对象移到组件外部，避免每次渲染重新创建

**代码示例**:
```javascript
// 优化前
export default function ConnectionsMetric() {
  const connectionPercent = maxConnections > 0
    ? Math.round((activeConnections / maxConnections) * 100)
    : 0
  // ...
}

// 优化后
export default function ConnectionsMetric() {
  const connectionPercent = useMemo(() =>
    maxConnections > 0
      ? Math.round((activeConnections / maxConnections) * 100)
      : 0,
    [activeConnections, maxConnections]
  )
  // ...
}
```

#### 4. 工具函数库

**新增文件**: `frontend/src/utils/debounce.js`

**功能**:
- `debounce(func, delay)` - 防抖函数
- `throttle(func, delay)` - 节流函数

**用途**:
- 高频事件处理（如窗口 resize、scroll）
- 状态更新优化（可后续应用到 monitorStore）

### 技术亮点

#### 后端
1. **原子操作**：使用 `AtomicU64` 替代 Mutex 保护的计数器，减少锁竞争
2. **线程安全**：连接数检查使用 `try_lock()` 避免阻塞
3. **RAII 模式**：ConnectionGuard 确保连接数准确追踪
4. **监控增强**：新增拒绝连接指标，便于告警

#### 前端
1. **零依赖**：BroadcastChannel 是浏览器原生 API，无需额外库
2. **兼容性好**：支持 Chrome 54+, Firefox 38+, Safari 10.1+
3. **智能降级**：不支持时自动降级到独立连接
4. **性能提升**：React 性能优化减少渲染开销

### 效果预期

- **WebSocket 连接数**：从 N 个/用户降低到 1 个/用户（减少 80%+）
- **VLESS 连接**：实际限制 1000 个，防止资源耗尽
- **前端性能**：减少不必要的重渲染，提升 UI 流畅度
- **监控能力**：新增 rejected_connections 指标，便于告警

### 向后兼容性

✅ **完全兼容**
- 配置文件自动使用新默认值
- 旧 config.json 无需手动修改
- 前端降级机制确保功能可用

### 测试建议

#### 后端测试
```bash
# 1. 编译项目
cargo build --release

# 2. 运行服务器
./target/release/vless-rust

# 3. 使用测试脚本创建 1001 个连接
# 验证第 1001 个被拒绝

# 4. 检查监控 API
curl http://localhost:8443/api/stats | jq '.rejected_connections'
```

#### 前端测试
1. 在浏览器中打开 10 个标签页
2. 检查后端日志，应该只有 1 个 WS 连接
3. 关闭主标签页，验证 10 秒内有新标签页接管
4. 所有标签页数据应保持同步

### 相关文件

#### 后端
- `src/config.rs` - 默认配置修改
- `src/stats.rs` - 拒绝连接计数器
- `src/server.rs` - VLESS 连接检查逻辑

#### 前端
- `frontend/src/api/ws-coordinator.js` - WebSocket 协调器（新增）
- `frontend/src/utils/debounce.js` - 防抖工具（新增）
- `frontend/src/store/monitorStore.js` - 协调器集成
- `frontend/src/components/metrics/*.jsx` - 性能优化
- `frontend/src/components/ResourceCard.jsx` - 性能优化
- `frontend/src/components/SystemInfo.jsx` - 性能优化

#### 文档
- `docs/technology.md` - 文件映射关系更新

---

## 2026-02-08 更新：图表布局和Y轴刻度优化

### 概述

优化流量趋势图的布局比例、图表高度和 Y 轴刻度显示逻辑,提供更好的视觉效果和数据可读性。

### 主要变更

#### 1. 布局优化

**修改文件**: `frontend/src/App.jsx`

**变更内容**:
- 网格列数: `lg:grid-cols-3` → `lg:grid-cols-6`
- 流量图跨列: `lg:col-span-2` → `lg:col-span-5`
- 系统面板跨列: `lg:col-span-1` (保持不变)

**效果**:
- 流量图占据更宽的空间 (5/6 vs 2/3)
- 系统面板占据更窄的空间 (1/6 vs 1/3)
- 整体布局更加灵活,适配不同屏幕尺寸

#### 2. 图表尺寸调整

**修改文件**: `frontend/src/components/charts/TrafficChartSection.jsx`

**变更内容**:
- 图表高度: `height={500}` → `height={300}`
- 添加负边距: `className="pt-2 -ml-8"` (用于调整图表左右位置)

**效果**:
- 图表更紧凑,减少页面占用空间
- 流量图和系统面板高度更协调

#### 3. Y轴刻度优化

**修改文件**: `frontend/src/components/charts/SpeedChart.jsx`

**新增功能**:

1. **固定刻度数量**:
   ```javascript
   // 计算 Y 轴刻度值（固定5个刻度）
   const yAxisTicks = useMemo(() => {
     const ticks = []
     for (let i = 0; i <= 4; i++) {
       ticks.push((maxY / 4) * i)
     }
     return ticks
   }, [maxY])
   ```

2. **改进的最大值计算**:
   - 添加 15% 缓冲空间,避免数据紧贴图表顶部
   - 根据数值范围动态选择向上取整精度
   - 小于1MB时,向上取整到0.1的倍数
   - 1-10MB时,向上取整到0.5的倍数
   - 大于10MB时,向上取整到整数

3. **图表样式调整**:
   - 初始宽度: `600` → `1400` (更接近实际容器宽度)
   - 左边距: `55` → `115` (为Y轴标签预留更多空间)
   - 右边距: `30` → `20` (减少右侧空白)
   - 顶边距: `20` → `40` (为图例预留空间)
   - 底边距: `50` → `35` (优化X轴标签显示)
   - 字体大小: `11px` → `12px` (提升可读性)
   - 线条宽度: `2px` → `3px` (增强视觉对比)

4. **图例位置优化**:
   - 位置: 固定 `x=60` → 动态 `x={chartWidth - 130}`
   - 添加 `anchor="end"` 对齐方式
   - 字体大小: `12px` → `13px`

**效果**:
- Y轴刻度固定为5个,显示更一致
- 刻度值动态计算,避免奇怪的小数
- 图表在不同数据规模下都有良好的显示效果
- 图例始终位于右上角,不遮挡数据

### 技术细节

#### Y轴刻度计算流程

```
1. 获取数据最大值 (maxUpload, maxDownload)
   ↓
2. 判断是否小于默认值 (0.195 MB/s)
   ↓ (是)
   使用默认值 0.195 MB/s
   ↓ (否)
3. 添加15%缓冲: bufferedMax = max * 1.15
   ↓
4. 根据缓冲值向上取整:
   - < 1MB → 取整到0.1的倍数
   - 1-10MB → 取整到0.5的倍数
   - > 10MB → 取整到整数
   ↓
5. 生成5个均匀分布的刻度值
```

#### 布局比例对比

| 元素 | 修改前 | 修改后 | 变化 |
|------|--------|--------|------|
| 网格列数 | 3列 | 6列 | +100% |
| 流量图占比 | 2/3 (66.7%) | 5/6 (83.3%) | +25% |
| 系统面板占比 | 1/3 (33.3%) | 1/6 (16.7%) | -50% |
| 图表高度 | 500px | 300px | -40% |

### 效果预览

**修改前**:
- 流量图占据中等宽度
- Y轴刻度数量不固定
- 图表高度较高
- 图例位置固定在左侧

**修改后**:
- 流量图占据更宽空间
- Y轴固定5个刻度,显示更整齐
- 图表更紧凑
- 图例始终在右上角

### 已知问题

⚠️ **负边距使用**:
- 使用 `-ml-8` 是一种 hack 方式,可能导致某些屏幕尺寸下布局异常
- 建议: 后续考虑调整图表内部的 padding 值

⚠️ **大屏幕布局**:
- 在超大屏幕(>1920px)上,系统面板可能过于狭窄
- 建议: 添加 `xl:breakpoint` 进一步优化布局比例

⚠️ **初始宽度值**:
- `useState(1400)` 可能导致首次渲染时图表过宽
- 建议: 使用 `window.innerWidth` 或更合理的默认值

### 向后兼容性

✅ **完全兼容**
- 数据格式不变
- API接口不变
- 组件props向后兼容
- 只是视觉和布局层面的优化

### 相关文件

- `frontend/src/App.jsx` - 布局网格调整
- `frontend/src/components/charts/SpeedChart.jsx` - Y轴刻度和样式优化
- `frontend/src/components/charts/TrafficChartSection.jsx` - 图表高度和边距调整

---

## 2026-02-08 更新：跨平台构建修复

### 概述

修复 GitHub Actions 中 ARM64 Linux 交叉编译失败的问题,改进静态链接配置,提升跨平台编译稳定性。

### 问题描述

在 GitHub Actions 中构建 `aarch64-unknown-linux-gnu` 目标时失败,错误信息:

```
error: failed to run custom build command for `openssl-sys v0.9.111`
Could not find directory of OpenSSL installation
```

**根本原因**:
- `reqwest` crate 使用 `native-tls` feature,依赖系统的 OpenSSL 库
- ARM64 交叉编译时需要目标架构(aarch64)的 OpenSSL 开发库
- GitHub Actions 环境未安装 aarch64 版本的 OpenSSL

### 解决方案

#### 1. TLS 库替换

**修改文件**: `Cargo.toml`

**变更内容**:
```toml
# 修改前
reqwest = { version = "0.11", default-features = false, features = ["native-tls"] }

# 修改后
reqwest = { version = "0.11", default-features = false, features = ["rustls-tls"] }
```

**优势**:
- `rustls-tls` 是纯 Rust 实现,无需系统 OpenSSL 库
- 更容易静态链接
- 更好的跨平台兼容性
- 内存占用更小,安全性更高

#### 2. 静态链接配置优化

**修改文件**: `.cargo/config.toml`

**新增配置**:
```toml
# Linux 静态链接配置（gnu - x86_64）
[target.x86_64-unknown-linux-gnu]
rustflags = ["-C", "link-self-contained=yes"]

# Linux 静态链接配置（gnu - aarch64）
[target.aarch64-unknown-linux-gnu]
rustflags = ["-C", "link-self-contained=yes"]
```

**说明**:
- 使用 `link-self-contained=yes` 替代 `target-feature=+crt-static`
- 更标准的静态链接方式,兼容性更好
- 在配置文件中统一管理,避免 workflow 中重复设置

#### 3. GitHub Actions 简化

**修改文件**: `.github/workflows/build.yml`

**删除步骤**:
- `Configure static linking for Linux` (已移至 config.toml)
- `Configure static linking for Windows` (已移至 config.toml)

**优化步骤**:
```yaml
- name: Install cross-compilation tools (Linux ARM64)
  if: matrix.target == 'aarch64-unknown-linux-gnu'
  run: |
    sudo apt-get update
    sudo apt-get install -y gcc-aarch64-linux-gnu
    echo "CARGO_TARGET_AARCH64_UNKNOWN_LINUX_GNU_LINKER=aarch64-linux-gnu-gcc" >> $GITHUB_ENV
    echo "CC_aarch64_unknown_linux_gnu=aarch64-linux-gnu-gcc" >> $GITHUB_ENV
```

**改进**:
- 添加 `CC` 环境变量,确保 C 编译器正确配置
- 移除重复的静态链接配置,简化 workflow

### 技术细节

#### rustls vs native-tls 对比

| 特性 | native-tls | rustls-tls |
|------|-----------|------------|
| 实现方式 | 系统OpenSSL绑定 | 纯Rust实现 |
| 外部依赖 | OpenSSL开发库 | 无 |
| 静态链接 | 复杂 | 简单 |
| 交叉编译 | 需要目标架构库 | 无需额外配置 |
| 性能 | 略高(本地优化) | 略低(可忽略) |
| 安全性 | 依赖系统版本 | 独立实现,更新快 |

#### 静态链接配置对比

| 配置方式 | 位置 | 优缺点 |
|---------|------|--------|
| `target-feature=+crt-static` | workflow环境变量 | 优点:强制静态<br>缺点:某些平台不支持 |
| `link-self-contained=yes` | .cargo/config.toml | 优点:标准方式,兼容性好<br>缺点:需要Rust 1.64+ |

### 构建目标支持

修复后,项目支持以下目标的静态编译:

| 目标三元组 | 平台 | 架构 | 状态 |
|-----------|------|------|------|
| x86_64-pc-windows-msvc | Windows | AMD64 | ✅ |
| x86_64-unknown-linux-gnu | Linux | AMD64 | ✅ |
| aarch64-unknown-linux-gnu | Linux | ARM64 | ✅ |

### 向后兼容性

✅ **完全兼容**
- TLS 层对应用透明,无需修改代码
- rustls 兼容所有现代 HTTPS 服务器
- 性能差异可忽略(毫秒级)

### 测试验证

```bash
# 1. 本地编译检查
cargo check

# 2. 本地构建测试
cargo build --release

# 3. 交叉编译测试(需要安装工具链)
rustup target add aarch64-unknown-linux-gnu
cargo build --release --target aarch64-unknown-linux-gnu
```

### 预期效果

- ✅ GitHub Actions 所有平台构建成功
- ✅ ARM64 Linux 可执行文件正常生成
- ✅ 静态链接,无动态库依赖
- ✅ 二进制文件保持单文件部署特性

### 相关文件

- `Cargo.toml` - reqwest feature 修改
- `.cargo/config.toml` - 静态链接配置新增
- `.github/workflows/build.yml` - workflow 简化

---

## 2026-02-08 更新：完整跨平台静态链接 CI/CD 构建

### 概述

增强 GitHub Actions CI/CD 工作流，实现全面的跨平台静态链接构建，支持 Windows、Linux 和 macOS 的多个架构，确保二进制文件在任何平台都能独立运行。

### 主要变更

#### 1. 新增平台支持

**修改文件**: `.github/workflows/build.yml`

**新增构建目标**:

| 平台 | 架构 | 目标三元组 | 文件名 |
|------|------|-----------|--------|
| Windows | AMD64 | x86_64-pc-windows-msvc | vless-rust-windows-amd64.exe |
| Windows | ARM64 | aarch64-pc-windows-msvc | vless-rust-windows-arm64.exe |
| Linux | AMD64 (musl) | x86_64-unknown-linux-musl | vless-rust-linux-amd64-musl |
| Linux | AMD64 (gnu) | x86_64-unknown-linux-gnu | vless-rust-linux-amd64-gnu |
| Linux | ARM64 | aarch64-unknown-linux-gnu | vless-rust-linux-arm64 |
| Linux | ARMv7 | armv7-unknown-linux-gnueabihf | vless-rust-linux-armv7 |
| macOS | Intel | x86_64-apple-darwin | vless-rust-macos-amd64 |
| macOS | Apple Silicon | aarch64-apple-darwin | vless-rust-macos-arm64 |

**平台覆盖**:
- ✅ Windows x64 + ARM64（覆盖现代 Windows 设备）
- ✅ Linux musl（完全静态链接，推荐）
- ✅ Linux gnu（兼容老旧发行版）
- ✅ Linux ARM64（服务器、树莓派4+）
- ✅ Linux ARMv7（树莓派3等）
- ✅ macOS Intel + Apple Silicon

#### 2. 构建流程改进

**新增功能**:

1. **Linux musl 工具链安装**:
   ```yaml
   - name: Install musl tools (Linux musl)
     if: matrix.target == 'x86_64-unknown-linux-musl'
     run: |
       sudo apt-get update
       sudo apt-get install -y musl-tools musl-dev
   ```

2. **ARMv7 交叉编译支持**:
   ```yaml
   - name: Install ARM cross-compilation tools
     if: startsWith(matrix.target, 'aarch64-unknown-linux') || matrix.target == 'armv7-unknown-linux-gnueabihf'
     run: |
       # 根据目标安装对应工具链
       if [ "${{ matrix.target }}" == "armv7-unknown-linux-gnueabihf" ]; then
         sudo apt-get install -y gcc-arm-linux-gnueabihf
         echo "CARGO_TARGET_ARMV7_UNKNOWN_LINUX_GNUEABIHF_LINKER=arm-linux-gnueabihf-gcc" >> $GITHUB_ENV
       fi
   ```

3. **静态链接验证**:
   ```yaml
   - name: Verify static linking (Linux)
     if: startsWith(matrix.os, 'ubuntu')
     run: |
       binary="target/${{ matrix.target }}/release/${{ matrix.artifact_name }}"
       file "$binary"
       ldd "$binary" 2>&1 | grep -q "not a dynamic executable" && echo "✓ 静态链接"
   ```

4. **二进制信息展示**:
   - 显示文件类型（file 命令）
   - 显示文件大小（ls -lh）
   - 便于快速验证构建结果

#### 3. 发布流程优化

**新增功能**:

1. **自动生成发布说明**:
   ```markdown
   ## 跨平台静态链接构建

   所有平台的二进制文件均为静态链接构建，无需额外依赖即可运行。

   ### 下载说明

   根据您的系统选择对应的文件：

   - **Windows AMD64**: `vless-rust-windows-amd64.exe`
   - **Linux AMD64 (musl)**: `vless-rust-linux-amd64-musl` - 完全静态链接，推荐使用
   - **macOS ARM64**: `vless-rust-macos-arm64` - Apple Silicon Mac
   ```

2. **文件命名改进**:
   - Windows 文件自动添加 `.exe` 扩展名
   - 非 Windows 文件保持无扩展名
   - 平台和架构清晰标识在文件名中

3. **执行权限自动设置**:
   ```bash
   chmod +x release/* 2>/dev/null || true
   ```

#### 4. 静态链接配置完善

**修改文件**: `.cargo/config.toml`

**新增配置**:

```toml
# Windows ARM64
[target.aarch64-pc-windows-msvc]
rustflags = ["-C", "target-feature=+crt-static"]

# Linux ARMv7
[target.armv7-unknown-linux-gnueabihf]
rustflags = ["-C", "link-self-contained=yes"]

# macOS (x86_64 + ARM64)
[target.x86_64-apple-darwin]
rustflags = []

[target.aarch64-apple-darwin]
rustflags = []
```

**说明**:
- macOS 默认静态链接系统库，无需特殊配置
- Windows ARM64 使用 CRT 静态链接
- Linux ARMv7 使用自包含链接

#### 5. 工作流触发优化

**新增触发方式**:

```yaml
on:
  push:
    tags:
      - 'v*'
  pull_request:
    branches: [ main ]
  workflow_dispatch:  # 新增：支持手动触发
```

**说明**:
- 标签推送（v*）自动构建并发布
- PR 到 main 分支仅构建测试
- 支持手动触发，方便测试构建流程

### 技术细节

#### 构建策略

**矩阵构建**:
- 使用 GitHub Actions `matrix` 策略并行构建
- `fail-fast: false` 确保单个平台失败不影响其他平台
- 每个目标独立构建，互不干扰

**依赖安装**:
- Node.js 20（前端构建）
- Rust stable（自动检测目标平台）
- 交叉编译工具链（条件安装）

#### 静态链接验证

**Linux 平台验证步骤**:

```bash
# 1. 检查文件类型
file vless-rust-linux-amd64-musl
# 输出: ELF 64-bit LSB executable, x86-64, statically linked

# 2. 检查动态库依赖
ldd vless-rust-linux-amd64-musl
# 输出: not a dynamic executable

# 3. 验证静态链接成功
if ldd "$binary" 2>&1 | grep -q "not a dynamic"; then
  echo "✓ 静态链接"
fi
```

**macOS 验证**:
```bash
file vless-rust-macos-arm64
# 输出: Mach-O 64-bit executable arm64
```

**Windows 验证**:
```bash
file vless-rust-windows-amd64.exe
# 输出: PE32+ executable (console) x86-64, for MS Windows
```

#### 发布流程

```
触发条件
  ↓
矩阵构建（8个平台并行）
  ↓
上传构建产物
  ↓
下载所有产物
  ↓
重命名和整理
  ↓
生成发布说明
  ↓
创建 GitHub Release
```

### 构建产物

**文件命名规则**:

```
vless-rust-{平台}-{架构}{扩展名}
```

**示例**:
- `vless-rust-windows-amd64.exe`
- `vless-rust-linux-amd64-musl`
- `vless-rust-macos-arm64`

**文件大小参考**:
- Windows x64: ~1.5 MB
- Linux musl: ~1.2 MB
- macOS ARM64: ~1.0 MB

### 使用说明

#### 开发者：触发构建

**方式一：标签推送**
```bash
git tag v1.0.0
git push origin v1.0.0
```

**方式二：手动触发**
1. 访问 GitHub Actions 页面
2. 选择 "Build Multi-Platform Static" 工作流
3. 点击 "Run workflow"
4. 选择分支并确认

#### 用户：下载使用

1. 访问 [Releases](https://github.com/xxx/vless-rust/releases) 页面
2. 根据系统选择对应的二进制文件
3. 下载并添加执行权限（Linux/macOS）:
   ```bash
   chmod +x vless-rust-xxx
   ```
4. 运行:
   ```bash
   ./vless-rust-xxx
   # 或 Windows
   vless-rust-windows-amd64.exe
   ```

### 向后兼容性

✅ **完全兼容**
- 现有工作流配置平滑升级
- 二进制文件格式不变
- 不会破坏现有 Release

### 测试验证

```bash
# 1. 推送测试标签
git tag v1.0.0-test
git push origin v1.0.0-test

# 2. 监控 GitHub Actions
# 检查所有8个平台是否成功构建

# 3. 下载构建产物测试
wget https://github.com/xxx/vless-rust/releases/download/v1.0.0-test/vless-rust-linux-amd64-musl
chmod +x vless-rust-linux-amd64-musl
./vless-rust-linux-amd64-musl

# 4. 验证静态链接
ldd vless-rust-linux-amd64-musl
```

### 预期效果

- ✅ 8个平台并行构建，总耗时约10-15分钟
- ✅ 所有平台静态链接，无动态库依赖
- ✅ 自动生成详细的发布说明
- ✅ 二进制文件可直接运行，无需额外依赖
- ✅ 支持手动触发，方便测试

### 已知限制

⚠️ **macOS 签名**:
- 未添加 Apple 开发者签名
- macOS 首次运行可能需要允许未签名应用
- 解决方案：右键点击 → 打开，或在系统设置中允许

⚠️ **Windows Defender**:
- 可能误报未签名二进制文件
- 解决方案：添加到排除列表

⚠️ **构建时间**:
- 8个平台并行构建，首次运行较慢
- 后续构建因缓存会更快

### 相关文件

- `.github/workflows/build.yml` - CI/CD 工作流（完整重写）
- `.cargo/config.toml` - 静态链接配置（新增目标）
- `Cargo.toml` - 项目依赖（无需修改）
- `docs/technology.md` - 技术文档更新（待更新）

---

## 2026-02-08 更新：基于提交信息的自动版本识别和构建

### 概述

优化 GitHub Actions CI/CD 工作流，实现基于提交信息的自动版本识别、去重构建和自动标签推送，简化发布流程。

### 主要变更

#### 1. 触发机制改进

**修改文件**: `.github/workflows/build.yml`

**修改前**:
```yaml
on:
  push:
    tags:
      - 'v*'  # 需要手动创建并推送标签
```

**修改后**:
```yaml
on:
  push:
    branches: [ main ]  # 推送到 main 分支自动触发
```

**优势**:
- ✅ 无需手动创建标签
- ✅ 提交即可触发构建
- ✅ 自动识别版本号
- ✅ 避免重复构建

#### 2. 版本识别机制

**新增 Job**: `extract-version`

**功能**:
1. **分析提交历史**:
   - 从最新 Release 标签开始分析提交
   - 查找符合版本格式的提交信息
   - 版本格式：`x.x.x` 或 `x.x.xx`（例如：1.0.0, 1.5.12）

2. **版本提取逻辑**:
   ```bash
   # 获取自上次 Release 之后的提交
   COMMITS=$(git log $LATEST_TAG..HEAD --pretty=format:"%s" --reverse)

   # 提取第一个匹配的版本号
   VERSION=$(echo "$COMMITS" | grep -m 1 -E '^[0-9]+\.[0-9]+\.[0-9]+')
   ```

3. **去重检查**:
   ```bash
   # 检查 Release 是否已存在
   HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" \
     "https://api.github.com/repos/xxx/releases/tags/v$VERSION")

   if [ "$HTTP_STATUS" == "200" ]; then
     echo "⚠ Release already exists, skipping build"
     exit 0
   fi
   ```

#### 3. 自动标签创建

**新增步骤**: 自动推送标签到仓库

```yaml
- name: Push tag to repository
  run: |
    git config user.name "github-actions[bot]"
    git config user.email "github-actions[bot]@users.noreply.github.com"
    git tag -a "$TAG_NAME" -m "Release $VERSION"
    git push origin "$TAG_NAME"
```

**说明**:
- 使用 GitHub Bot 身份创建标签
- 标签格式：`vx.x.x`（自动添加 v 前缀）
- 自动推送到远程仓库

#### 4. 工作流流程

```
推送到 main 分支
  ↓
extract-version Job
  ├─ 分析提交历史
  ├─ 提取版本号
  └─ 检查是否已构建
  ↓
判断 should_build
  ├─ true → 继续构建
  └─ false → 跳过构建
  ↓
build Job（8个平台并行）
  ├─ 编译前端
  ├─ 编译后端
  └─ 验证静态链接
  ↓
release Job
  ├─ 下载所有构建产物
  ├─ 生成发布说明
  ├─ 创建 GitHub Release
  └─ 自动推送标签
```

### 使用说明

#### 开发者：触发构建

**方式一：提交版本号（推荐）**

```bash
# 方式1：提交信息就是版本号
git commit -m "1.0.0"
git push origin main

# 方式2：提交信息包含版本号（不推荐，会被忽略）
git commit -m "Release 1.0.0"  # ❌ 不会被识别
git commit -m "1.0.0"          # ✅ 会被识别
```

**关键规则**:
- ✅ 提交信息**必须以版本号开头**
- ✅ 版本格式：`x.x.x`（例如：1.0.0, 1.5.12）
- ❌ 提交信息包含版本号但不在开头不会被识别
- ❌ 多个版本号提交只识别第一个

**方式二：手动触发**

```bash
# 访问 GitHub Actions 页面
# 选择 "Build Multi-Platform Static"
# 点击 "Run workflow"
```

#### 工作流行为

**场景1：首次发布**
```bash
# 提交历史
git log
# 1.0.0  <- 会被识别

# 工作流
# ✅ 提取版本 1.0.0
# ✅ 检查 Release 不存在
# ✅ 构建所有平台
# ✅ 创建 Release v1.0.0
# ✅ 推送标签 v1.0.0
```

**场景2：多个版本提交**
```bash
# 提交历史
git log
# 1.0.0  <- 已构建
# 1.0.1  <- 会被识别（第一个未构建版本）
# 1.0.2
# 1.0.3

# 工作流
# ✅ 提取版本 1.0.1（不是 1.0.2 或 1.0.3）
# ✅ 检查 Release 不存在
# ✅ 构建所有平台
# ✅ 创建 Release v1.0.1
# ✅ 推送标签 v1.0.1
```

**场景3：重复构建**
```bash
# 提交历史
git log
# 1.0.0  <- 已经构建并创建 Release

# 工作流
# ✅ 提取版本 1.0.0
# ⚠ 检查 Release 已存在
# ❌ 跳过构建（should_build=false）
```

**场景4：无版本号**
```bash
# 提交历史
git log
# fix bug in http handler  <- 不包含版本号

# 工作流
# ❌ 提取版本失败
# ❌ 跳过构建（should_build=false）
```

### 技术细节

#### 版本提取正则

```bash
# 匹配规则
grep -m 1 -E '^[0-9]+\.[0-9]+\.[0-9]+'

# 有效格式
1.0.0    ✅
1.5.12   ✅
0.9.99   ✅

# 无效格式
v1.0.0   ❌（有 v 前缀）
Release 1.0.0  ❌（不在行首）
1.0      ❌（只有两位）
1.0.0.0  ❌（四位）
```

#### 去重检查机制

```bash
# GitHub API 检查
curl "https://api.github.com/repos/xxx/releases/tags/v1.0.0"

# 返回码
200 -> Release 存在，跳过构建
404 -> Release 不存在，执行构建
```

#### 标签命名规则

```
提取版本: 1.0.0
标签名称: v1.0.0
Release 标题: Release 1.0.0
```

### 向后兼容性

⚠️ **破坏性变更**:
- **旧方式**: 推送标签 `v*` 触发构建
- **新方式**: 推送提交到 `main` 分支触发构建

**迁移指南**:

如果你已经推送了标签但未触发构建：

```bash
# 删除远程标签（如果存在）
git push origin --delete v1.0.0

# 重新提交（提交信息为版本号）
git commit --allow-empty -m "1.0.0"
git push origin main

# 工作流会自动创建标签和 Release
```

### 最佳实践

#### 推荐工作流

```bash
# 1. 开发新功能
git add .
git commit -m "add new feature"

# 2. 准备发布时，创建版本提交
git commit --allow-empty -m "1.0.0"

# 3. 推送到 main
git push origin main

# 4. GitHub Actions 自动构建
#    - 提取版本 1.0.0
#    - 构建 8 个平台
#    - 创建 Release
#    - 推送标签 v1.0.0
```

#### 提交信息规范

```bash
# ✅ 正确
git commit -m "1.0.0"
git commit -m "1.5.12"

# ❌ 错误
git commit -m "Release 1.0.0"
git commit -m "v1.0.0"
git commit -m "Version 1.0.0"
```

#### 多人协作

```bash
# 开发者 A
git commit -m "1.0.0"
git push origin main  # 触发构建 v1.0.0

# 开发者 B（稍后推送）
git commit -m "1.0.1"
git push origin main  # 触发构建 v1.0.1（不会重新构建 1.0.0）
```

### 已知限制

⚠️ **版本号格式**:
- 必须是 `x.x.x` 格式（三位）
- 不支持 `v` 前缀
- 不支持语义化版本前缀（如 `release-1.0.0`）

⚠️ **提交顺序**:
- 如果有多个版本号提交，只构建第一个未构建的版本
- 例如：提交历史有 1.0.0, 1.0.1, 1.0.2，只会构建 1.0.0

⚠️ **分支限制**:
- 只在 `main` 分支触发
- 其他分支不会触发构建

### 预期效果

- ✅ 无需手动创建标签
- ✅ 自动识别版本号
- ✅ 避免重复构建
- ✅ 自动推送标签到仓库
- ✅ 简化发布流程

### 相关文件

- `.github/workflows/build.yml` - CI/CD 工作流（版本识别逻辑）
